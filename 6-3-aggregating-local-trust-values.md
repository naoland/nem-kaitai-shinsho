6.3 各ノードに保存されたローカル信頼度を集計する

みなさん、おはようございます。

前回、それぞれのNISノード（計算機）が、どのように通信した相手の信頼度（＝通信成功率）を数値化しているか分かりました。

今回は、その値を他のNISノードとどのように共有しているかについてです。

----

# 6.3 ローカル信頼度の集計

 

ノードは度々他のノードに対して、自分が持っているローカル信頼度リストをブロードキャストします。

ノード（k）から信頼度リストを受け取ったノード（i）は、ノード（j）の信頼度をノード（k）から送られてきた信頼度cjkと、自分とノード（j）の間の信頼度cijをかけ合わせてtikを算出します。

![](https://s3-ap-northeast-1.amazonaws.com/nem-social/blog/10000/11000/11700/11754/1548206155%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202019-01-23%2010.09.57.png)

```
この式にΣがついているのは、ノード(i)とノード(k）が共に通信したことのあるノードについての数値をすべて足し合わせてノード（i）とノード(k）間の信頼度を計算するという意味です（どちらかしか通信していないノードは掛け算すると０になる）。そのため、下の行列の掛け算で表すことができます。
```

この式は、ckjをまとめた行列Cと、tikをまとめたベクトルtiを定義することで以下のように書き換える事ができます。

![](https://s3-ap-northeast-1.amazonaws.com/nem-social/blog/10000/11000/11700/11754/1548207037%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202019-01-23%2010.10.11.png)

と書くことができます。そしてtiがCの固有ベクトルtに収束するためには、２つの条件が必要です。

行列Cが規約行列であることと、非振動的であること。

```
この２つの行列の性質は高度なので無視しますが、tがなんらかの数値に落ち着くための条件と考えておきます。
```

この性質を保証するために、上の式を初期ベクトルpを使って少しだけ変更します。

![](https://s3-ap-northeast-1.amazonaws.com/nem-social/blog/10000/11000/11700/11754/1548208842%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202019-01-23%2010.10.59.png)

ここで、aは0 < a < 1を満たします。aを適切な値に設定することで、ある特定のノードに対して、他のすべてのノードが持つ信頼度が固有ベクトルtへと収束することが約束されます。

----

```
コメント：

ここを読んで思ったこと。

「この行列オタクめ！」

です。

要するに、複数のノードがお互いに高い成功率で通信している場合、このノード群内のノード間の信頼度は上がります。逆に、共有しているノードが少ないと、数値は低くなるでしょう。そして、ネットワーク上における各ノードの信頼度は、あるひとつの数値に収束してほしくて、振動したり発散したりしては困るわけです。ある特定のノードへの信頼度が０と１の間のどこかに収束してくれれば、十分な時間が経過した後では、ネットワーク上のすべてのノードが、同じ信頼度ベクトル（t）を共有するのとほぼ同じ事になるからです。

しかし、この希望的な定義が、ネットワークの弱点にもなります。悪意ある人が、信頼度ベクトルが収束することを妨げるようなリストを送り込み続けた場合にどうなるか。その改善策を次回は読み解きます。
```
